# 사용자 정의 인증

스프링 시큐리티는 사용자 인증을 위해 다양한 방법을 제공한다.   
이러한 방법들은 모두 SecurityContext 안에 Authentication 으로 채우는 과정이다.   
Authentication 객체는 인증 시 수집한 모든 정보(사용자명, 패스워드, 역할) 을 나타내고,    
SecurityContext 인터페이스는 SecurityContextHolder 인터페이스에 설정된다.   

즉 SecurityContextHolder 를 사용해 현재 로그인한 사용자에 대한 정보를 얻을 수 있는 것이다.   

```kotlin
val username = SecurityContextHolder.getContext().authentication.name
```

> Authentication 객체 사용 시 사용자가 로그인하지 않은 경우       
> null 이 리턴되므로 null 체크가 필요하다   

## 인증(Authentication) 메서드의 선택

### SecurityContextHolder

사용자를 인증하는 방법 중에서 가장 쉬운 방법이다.   
SecurityContextHolder 는 새롭게 생성된 사용자를 인증하거나 비정상적 방식으로 인증을 시도할 때 잘 동작한다.   
SecurityContextHolder를 직접 사용하여 여러 시큐리티 계층과 상호 작용할 필요가 없다.   
하지만 이 경우 시큐리티가 제공하는 고급기능의 혜택을 볼 수 없다.   
예를 들어 로그인 후 요청 페이지로 사용자를 리다이렉트하려면 컨트롤러에서 처리를 진행해야 한다.

### UserDetailsService

커스텀 UserDetailsService 객체를 생성하면 스프링 시큐리티에 손쉽게 보안 메커니즘을 제공할 수 있다.   
다른 스프링 시큐리티 기능에 연결하기도 손쉽다.   
예를 들어 Remember-Me 서비스에 활용된다.   
하지만 UserDetailsService 객체는 사용자명과 패스워드를 기본으로 인증하지 않는 경우에는 사용할 수 없다.

### AuthenticationProvider(인증 제공자)

스프링 시큐리티에서 가장 활용성이 높은 방법이다.   
AuthenticationProvider 는 개발자가 원하는 매개변수를 통해 인증을 수행하도록 만들 수 있다.   
하지만 스프링 시큐리티의 Remember-Me 기능을 쓰고싶다면 UserDetailsService 를 사용해야 한다.

## UserDetailsService 다루기

### InMemoryUserDetailsManager 를 활용한 새로운 사용자 추가 - 인증 추가

> UserDetailsService <- UserDetailsManager <- InMemoryUserDetailsManager

스프링 시큐리티는 사용자를 관리하기 위해 UserDetailsManager 인터페이스를 제공한다.   
예를 들어 인메모리 스프링 보안 설정이 있으며 이 경우 InMemoryUserDetailsManager 라는    
UserDetailsManger(UserDetailsService 의 자식 인터페이스) 의 구현체가 사용된다.   

WebSecurityConfigurerAdapter 를 상속한 커스텀 SecurityConfig 에 
configure(AuthenticationManagerBuilder) 를 오버로딩해서 설정하는 방식 대신에      
userDetailsService() : UserDetailsService 를 오버로딩 하면 UserDetailsManager 를 등록할 수 있다.  

```kotlin
@Bean
override fun userDetailsService() : UserDetailsManager {
    return InMemoryUserDetailsManager().apply {
        createUser(User.withUsername("user").password("{noop}user").roles("USER").build())
        createUser(User.withUsername("admin").password("{noop}admin").roles("USER","ADMIN").build())
    }
}
```

> 원래는 UserDetailsService 이지만 UserDetailsManager 로 리턴 타입을 변경할 수 있다.      
> 이는 인터페이스가 상속관계에 있기 때문이다.   

이렇게 userDetailsManager 가 빈으로 노출되면(시큐리티에 등록된 상태이다) 다른 서비스에서   
이를 주입받아 새로운 유저를 추가할 수 있다.   

```kotlin
@Service
class PersonService(
    val userDetailsManager: UserDetailsManager
) {
    fun getAuthenticationName() : String { // SecurityContextHolder 를 활용해 현재 로그인한 유저 탐색
        return SecurityContextHolder.getContext().authentication.name
    }

    fun createUser(user: PersonRequest) : String {
        val authorities = AuthorityUtils.createAuthorityList("ROLE_USER")

        val userDetails = User(user.name, "{noop}${user.name}", authorities)
        userDetailsManager.createUser(userDetails)

        return user.name
    }
}
```

상기 코드처럼 AuthorityUtils 를 활용하면 손쉽게 Collection<GrantedAuthority> 를 구성할 수 있고,   
userDetails 를 생성해서 userDetailsManager 에 추가하기만 하면 된다.   
이러한 서비스를 앤드포인트에 노출하면 손쉽게 애플리케이션 바깥에서 새로운 유저를 추가할 수 있게되는 것이다.   

> 추가적으로 SecurityContextHolder 를 활용하면      
> 현재 로그인된 Authentication 정보를 새롭게 생성된 유저 정보로 바꿔치기할 수 있다.   

### 커스텀 UserDetailsService 구현

이전 단계에서는 InMemoryUserDetailsManager 를 통해 인증 정보를 다루었다.   
다음은 이러한 UserDetailsService 구현체를 직접 만들어보자.   

