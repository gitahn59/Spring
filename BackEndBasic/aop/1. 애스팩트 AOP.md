# 애스펙트 AOP

## 의존성과 빈 설정
부트에서 AspectJ AOP 를 사용하려면 starter-aop 의존성을 추가해야 한다.
부트는 별도의 @EnableAspectAutoProxy 를 사용할 필요가 없다.   

```kotlin
implementation("org.springframework.boot:spring-boot-starter-aop")
```

## 프록시 기반 AOP
AOP 는 모듈화된 어드바이스(부가 기능)과 포인트컷(적용 대상)의 조합을 통해       
여러 오브젝트에서 공통적으로 요구되는 기능을 손쉽게 제공하게 만들어준다.   

스프링에서는 자바 JDK 에서 지원하는 다이내믹 프록시를 사용하여 AOP 를 지원한다.
이 경우 빌드 과정이나 바이트코드 조작 기술이 필요 없다.
AOP 는 객체지향 디자인 패턴인 데코레이터나 프록시를 응용한다.     
기존 코드를 유지한 상태로 부가기능을 타깃 오브젝트에 제공한다.     
여기에 포인트 컷이라는 대상 선택 기법을 적용하여 특정한 메소드에만 부가 기능을 제공한다.   

### AOP 인터페이스 구현과 <bean> 등록을 이용한 방법
가장 기초적인 프록시 AOP 는 AOP 의 구성요소를 모두 클래스로 개발하고 빈으로 등록하는 것이다.   

1. 어드바이스와 포인트컷을 구현(둘 모두 스프링 제공 인터페이스를 구현)
2. 어드바이스와 포인트컷을 빈으로 등록하고, 둘을 조합해 어드바이저로 구성
3. 어드바이저도 빈으로 등록
4. 자동 프록시 생성기 빈을 등록하고 어드바이저를 지정(어드바이저를 프록시로 만들어줌)

하나의 어드바이스는 여러 포인트컷과 연결될 수 있고, 그 반대도 가능하다.   

자동 프록시 생성기 빈은 DefaultAdvisorAutoProxyCreator 를 사용한다.   
빈으로 등록되면 빈으로 등록된 모든 어드바이저 내의 포인트컷을 사용해서 전달받은 빈이   
프록시 적용대상인지 확인하고 빈이 적용대상이면 프록시 오브젝트를 되돌려준다.   

### 임의의 자바 클래스와 aop 네임스페이스의 <aop:aspect> 를 이용하는 방법

애스펙트는 기본적으로 일반 자바 클래스를 이용해서 정의할 수 있다.   
애스펙트는 특정 인터페이스를 구현할 필요가 없이 오노테이션을 이용해 AOP 애스팩트로 만들 수 있다.   

인터페이스를 구현해야 하는 조건이 없으므로 메소드는 유연하게 정의할 수 있고,   
하나의 클래스 안에 여러 개의 애스펙트를 포함할 수 있다.   

### @AspectJ 애노테이션을 이용한 애스펙트 개발 방법
@AspectJ 는 이름 그대로 AspectJ AOP 프레임워크에서 정의된 애노테이션을 이용해 애스팩를 구현할 수 있게 만들어준다. 
이는 @AspectJ 문법과 애스팩트 정의 방법을 차용했을 뿐이고 AspectJ AOP 를 사용하는 것은 아니다.    
@AspectJ도 여타 방법과 같이 스프링의 프록시 기반 AOP 를 만들 때 사용한다.

### 자동 프록시 생성기와 프록시 빈
스프링 AOP 를 사용한다면 어떤 방식을 적용하던 모두 프록시 방식의 AOP 다.    
스프링의 프록시 개념은 데코레이터 패턴에서 나온 것이고, JDK 의 다이내믹 프록시와 DI를 이용한다.   
  
프록시를 만드는 방법에 따라 등록되는 빈의 종류와 사용 방법을 생각해보자.
Client 와 Target 이라는 클래스가 있고, Client 는 Target 을 DI 받아 사용할 것이다.       
이 때 프록시는 Client 와 Target 의 코드에 영향을 주지 않은 채로, 부가 기능을 제공하며   
Client 는 Target 의 구체적인 구현 타입을 알고 있으면 안된다.       

프록시는 DI에 기반을 두고 있으며, Target 클래스를 그대로 주입 받는다면 컨테이너와 설정을 통해 바꿀 수 없기 떄문이다.   
DI 원리에 의존하는 데코레이터 패턴이 적용된 프록시 방식이 클래스를 프록시로 대체할 수 없다.   
따라서 Client 가 Target 이라는 구체 클래스 대신 Target이 구현하고 있는 인터페이스를 의존하도록 해야 한다.   

> Client -> Proxy -> Target

인터페이스를 추가하는 과정은 스프링 입장에서 보면 빈을 하나 더 추가하는 셈이다.   
기존엔 Client 와 Target 에 대한 빈에 더아여 Proxy 빈이 추가된다.   

이 때 @Autowired 에서 문제가 발생한다.   
Proxy를 빈으로 등록하면 @Autowired 를 통한 타입 자동와이어링을 사용할 수 없다.   
프록시 방식을 적용하기 위해서 Client 는 인터페이스에 의존해야 한다.   
따라서 서로 같은 인터페이스를 구현하는 빈이 (Target, Proxy) 2개가 되어 타입 충돌이 발생한다.   
그렇다면 프록시를 사용하면 Autowired를 사용할 수 없는 것일까? => 물론 아니다.

스프링은 자동 프록시 생성기를 이용해서 컨테이너를 초기화 할 때 빈은 바꿔치기하여 프록시 빈을 자동으로 등록해준다.   
빈을 선택하는 로직은 포인트 컷을 활용하고, 바꿔치기는 빈 후처리기가 담당한다.   

이렇게 자동 프록시 생성기로 만들어진 빈은 수동 프록시 빈과 다르다.   
자동 프록시 빈은 Di 설정만 바꿔주는 게 아니라 프로시를 적용할 대상 자체를 아예 포장해서 그 빈이 된다.   
따라서 빈이 추가되는 것이 아니다.   

> 자동 프록시 생성기는 타겟을 프록시 안으로 감춘다.

#### AOP 적용은 @Autowired 에 의한 와이어링에 문제를 일으키지 않는다.

직접 타깃 오브젝트의 인터페이스를 구현한 프록시는 @Autowired 를 사용할 수 없다.
하지만 생성기를 이용하면 문제 없다.

#### AOP 적용은 다른 빈들이 Target 오브젝트에 직접 의존하지 못하게 한다.

자동 프록시 생성기는 Target 빈을 프록시 안에 감춰버린다.   
프록시는 근본적으로 Target 클래스와 동일한 인터페이스를 구현해야 한다.   
따라서 프록시 빈은 타겟이 구현한 Interface 타입을 갖게 될 것이다.   

기존에 Target 을 직접 의존하는 빈이 있다고 하자.   
AOP 적용 전에는 DI 적용에는 문제가 없었다.

하지만 AOP를 적용하여 자동 프록시 생성기에 의해 Target이 감추어지면서 문제가 발생한다.   
더 이상 Target 빈이 존재하지 않기 때문이다.   
따라서 Client 는 빈을 DI 받을 수 없어 예외가 발생한다.   

이를 해결하는 방법은 Client 가 타겟의 인터페이스를 의족하도록 만드는 것이다.
자동 프록시 생성기는 프로시가 Target 이 구현한 인터페이스 타입이 되도록 만들어지므로    
Client 가 의존하는 인터페이스에 주입될 수 있다.      

> AOP 를 적용할 때 Client 가 Target 을 직접 의존하면 예외가 발생한다.

## 프록시의 종류
위에서 사용된 프록시는 인터페이스를 구현한 프록시다.   
JDK 의 다이나믹 프록시가 인터페이스를 이용하고,      
데코레이터 패턴과 DI 도 인터페이스를 통한 의존관계를 사용한다.   

스프링에서는 클래스를 직접 참조하는 강한 의존관계를 맺고 있더라도 프록시를 적용할 수 있다.   
어떻게 인터페이스 없이도 프록시를 적용할 수 있을까?
바로 타깃 클래스 자체를 인터페이스로 활용하는 방법을 사용하기 때문이다.      
클라이언트가 타깃 인터페이스를 의존하는 것은 변하지 않지만, 타깃 클래스의 서브 클래스를 프록시로 사용한다.   

하지만 이러한 방법에는 한계가 있다.   
final 클래스와 메소드에는 적용할 수 없으며, 타깃 클래스의 생성자가 두 번 호출된다.   
final 클래스는 상속을 할 수 없기 때문에 같은 타깃 클래스 타입의 빈이 2개 만들어진다.       
클래스 프록시를 만들기 위해서는 CGLib 라는 바이트코드 생성 라이브러리가 필요하다.   

이 경우 JDK 의 다이내믹 프록시 API 로 가능했던 인터페이스 기반 프록시와 달리, 
CGLib 라는 외부 라이브러리 의존도가 발생한다.   
클래스를 이용한 프록시는 타깃 오브젝트의 public 메소드를 모두 프록시 대상으로 삼는다.   
따라서 프록시로 노출할 메소드를 선별할 수 없다.   

스프링이 이런 부자연스러럽고 복잡한 바이트 코드 생성 기술을 사용해서까지 기능을 지원하는 이유는 무엇일까?    
이는 래거시 코드나 외부에서 개발한 인터페이스 없는 라이브러리 클래스 등에도, AOP를 적용할 수 있게 해주려는 의도이다.   

클래스 프록시를 적용하는 방법을 두 가지다.
1. 인터페이스를 구현하지 않은 타깃 클래스에 AOP를 적용
    * 인터페이스가 있다면 인터페이스를 구현한 JDK 다이내믹 프록시 생성
    * 인터페이스가 없다면 CGLib를 이용한 클래스 프록시 생성
2. 강제로 클래스 프록시를 만들도록 설정
    * 인터페이스가 있어도 클래스 프록시 생성
    * proxy-target-class 를 true로 설정하면 된다.

## 코틀린과 스프링 프록시
코틀린은 기본적으로 class 에 대한 상속 여부가 final 로 설정되어있다.   
따라서 클래스 프록시를 생성하기 위해서는 open 제한자를 통해 상속을 허가해야한다.   

코틀린으로 스프링을 사용할 떄는 보통 plugin.spring 플러그인을 사용한다.  
이 플러그인의 역할은 스프링 애노테이션이 붙은 클래스를 open 으로 만들어준다.   

> 클래스를 빈으로 만들 때 aop 나 transaction 을 사용해서 proxy 로 만들 필요가 있다면,   
> 스프링 애노테이션을 설정하지않고 클래스에 open 을 설정하거나,   
> 스프링 애노테이션을 설정해(@Component, @Service 등) 자동으로 open 되도록 만들어야 한다.   

## @AspectJ AOP
애스펙트는 객체지향 언어의 클래스와 비슷한 개념이다.   
애스펙트는 그 자체로 애플리케이션의 도메인 로직을 담은 핵심 기능은 아니지만,   
많은 오브젝트에서 필요한 부가 기능을 추상화해놓은 것이다.   

구조적으로 보면 애스펙트는 하나 이상의 포인트컷과 어드바이스로 구성된다.   
스프링의 어드바이저는 하나의 포인트컷과 하나의 어드바이스로 정의된, 가장 단순한 애스펙트이다.   

독립적인 빈의 조합인 어드바이저와는 다르게,   
애스펙트는 다양한 조합을 갖는 포인트컷과 어드바이스를 하나의 모듈로 정의할 수 있다.   

@AspectJ는 애스펙트를 자바 클래스와 메소드, 애노테이션을 이용해서 정의하는 방법을 가리킨다.   

### @AspectJ를 이용하기 위한 준비사항

@AspectJ 라는 이름의 애노테이션은 없다. 이는 특정 AOP 개발 방법을 가리키는 용어이다.   
애노테이션 방식의 mvc 개발 방법을 @mvc 라고 부르듯이, 이도 마찬가지다.   

<aop: aspectj-autoproxy />

이러한 선언은 빈으로 등록된 클래스 중에서 클래스 레벨에 @Aspect 가 붙은 모든 것을 애스펙트로 등록한다.   
@AspectJ 에서 핵심 애노테이션은 @Aspect 이다.   

### @Aspect 클래스의 구성요소

애스펙트는 클래스에 @Aspect 라는 애노테이션을 붙여서 만든다.   
인터페이스 구현이나 클래스 상속을 강제하지 않는다는 의미이다.   
@Aspect 클래스는 기본적으로 @Configuration 처럼 메타정보로 활용된다.   
또한 어드바이스를 담당하는 메소드는 실행 가능하기 때문에 단위 테스트 등에 활용될 수 있다.   

```kotlin
@Aspect
class SimpleMonitoringAspect
```   

이 클래스를 애스팩트로 사용하려면 빈으로 등록해야 한다.   
1. @bean   
2. @Component 로 자동 스캔 등록

@Aspect 클래스에서는 포인트컷과 어드바이스를 정의할 수 있다.

### 포인트 컷 : @Pointcut

포인트컷은 @Pointcut 애노테이션이 달린 메소드를 이용한다.   
선택하는 로직은 @Pointcut 안에 포인트컷 표현식을 넣는다.  
단지 메소드의 선언부를 메타정보로 이용할 뿐이므로 구현부에는 내용을 비워도 된다.   

```kotlin
@Pointcut("execution(* hello(..))")
fun all() {
}
```

이렇게 정의된 포인트컷은 여러 어드바이스에서 사용될 수 있다.   

### 어드바이스 : @Before, @AfterReturning, @AfterThrowing, @After, @Around

어드바이스 역시 애노테이션 메소드를 통해 구현된다.      
@AspectJ 에서는 5 가지 어드바이스를 제공한다.   
어드바이스의 로직은 메소드 내의 코드로 작성된다.   

> 메소드의 파라미터와 리턴 값은 어드바이스 종류와 포인트컷에서 선언한 파라미터에 따라 달라진다.

어드바이스는 하나 이상을 정의할 수 있다.   
어드바이스의 애노테이션에는 적용할 포틴트컷을 명시해야 한다.   

AOP 인터페이스 구현 방식은 어드바이스와 포인트컷을 조합해 어드바이저를 정의하지만,   
애스펙트에서는 어드바이스에 포인트컷을 직접 속성으로 지정한다.   

```kotlin
@Aspect
@Component
class SimpleMonitoringAspect{
    @Pointcut("execution(* hello(..))")
    fun all(){}

    @Around("all()")
    fun printParametersAndReturnVal(pjp : ProceedingJoinPoint){
        
    }
}
```

상기 예제는 포인트컷에 이름을 부여해서 따로 정의하는 방법이다.
이러한 방식 대신에 곧바로 어드바이스 애노테이션 안에 포인트컷을 정의할수도 있다.

```kotlin
@Around("execution(* hello(..))")
fun printParametersAndReturnVal(pjp : ProceedingJoinPoint){
    
}
```

이렇게 하나의 애스펙트 안에 포인트컷이 있을 수도 있고 없을 수도 있으며 어드바이스 자체가 없을 수도 있다.   

